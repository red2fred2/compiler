use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
    r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
    r"\s*" => {},
    _,
}

pub Program: Vec<Declaration> = {
    <Globals>,
}

Globals: Vec<Declaration> = {
    <mut list: Globals> <item: Declaration> => {
        list.push(item);
        list
    },
    EPSILON => Vec::new(),
}

Declaration: Declaration = {
    <VariableDeclaration>,
    <ClassDeclaration>,
    <FunctionDeclaration>,
}

VariableDeclaration: Declaration = {
    <name: Id> COLON <t: Type> <assignment: (ASSIGN <Expression>)?> SEMICOLON => {
        Declaration::Variable { name, t, assignment }
     },
}

Type: Type = {
    <t: Primitive> => Type::Primitive(t),
    PERFECT <t: Primitive> => Type::PerfectPrimitive(t),
    <t: Id> => Type::Class(t),
    PERFECT <t: Id> => Type::PerfectClass(t),
}

Primitive: Primitive = {
    INT => Primitive::Int,
    BOOL => Primitive::Bool,
    VOID => Primitive::Void,
}

ClassDeclaration: Declaration = {
    <id: Id> COLON CLASS LCURLY <body: ClassBody> RCURLY SEMICOLON => {
        Declaration::Class { id, body }
    },
}

ClassBody: Vec<Declaration> = {
    <mut list: ClassBody> <item: VariableDeclaration> => {
        list.push(item);
        list
    },
    <mut list: ClassBody> <item: FunctionDeclaration> => {
        list.push(item);
        list
    },
    EPSILON => Vec::new(),
}

FunctionDeclaration: Declaration = {
    <id: Id> COLON LPAREN <fn_input: Formals> RPAREN <fn_output: Type> LCURLY <body: StatementList> RCURLY => {
        Declaration::Function { id, fn_input, fn_output, body }
    },
}

Formals: Vec<Formal> = {
    <FormalsList>,
    EPSILON => Vec::new(),
}

FormalsList: Vec<Formal> = {
    <item: FormalDeclaration> => vec![item],
    <mut list: FormalsList> COMMA <item: FormalDeclaration> => {
        list.push(item);
        list
    },
}

FormalDeclaration: Formal = {
    <id: Id> COLON <t: Type> => Formal { id, t },
}

StatementList: Vec<Statement> = {
    <mut list: StatementList> <item: Statement> => {
        list.push(item);
        list
    },
    // StatementList BlockStatement,
    EPSILON => Vec::new(),
}

BlockStatement: BlockStatement = {
    WHILE LPAREN <condition: Expression> RPAREN LCURLY <body: StatementList> RCURLY => {
        BlockStatement::While(condition, body)
    },
    IF LPAREN <condition: Expression> RPAREN LCURLY <body: StatementList> RCURLY <else_body: (ELSE LCURLY <StatementList> RCURLY)?> => {
        let else_body = match else_body {
            Some(x) => x,
            None => Vec::new(),
        };

        BlockStatement::If(condition, body, else_body)
    },
}

Statement: Statement = {
    <declaration: VariableDeclaration> => {
        Statement::VariableDeclaration(declaration)
    },
    <location: Loc> ASSIGN <expression: Expression> SEMICOLON => {
        Statement::Assignment(location, expression)
    },
    <location: Loc> POSTDEC SEMICOLON => {
        Statement::Decrement(location)
    },
    <location: Loc> POSTINC SEMICOLON => {
        Statement::Increment(location)
    },
    GIVE <expression: Expression> SEMICOLON => {
        Statement::Give(expression)
    },
    TAKE <location: Loc> SEMICOLON => {
        Statement::Take(location)
    },
    RETURN <expression: (<Expression>)?> SEMICOLON => {
        Statement::Return(expression)
    },
    EXIT SEMICOLON => {
        Statement::Exit
    },
    <call: CallExpression> SEMICOLON => {
        Statement::CallExpression(call)
    },
}

Expression: Expression = {
    <Expression1>,
}

Expression1: Expression = {
    <left: Expression1> OR <right: Expression2> => {
        Expression::Or(Box::new(left), Box::new(right))
    },
    <Expression2>
}

Expression2: Expression = {
    <left: Expression2> AND <right: Expression3> => {
        Expression::And(Box::new(left), Box::new(right))
    },
    <Expression3>,
}

Expression3: Expression = {
    <left: Expression3> EQUALS <right: Expression4> => {
        Expression::Equals(Box::new(left), Box::new(right))
    },
    <left: Expression3> NOTEQUALS <right: Expression4> => {
        Expression::NotEquals(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATER <right: Expression4> => {
        Expression::Greater(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATEREQ <right: Expression4> => {
        Expression::GreaterEq(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESS <right: Expression4> => {
        Expression::Less(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESSEQ <right: Expression4> => {
        Expression::LessEq(Box::new(left), Box::new(right))
    },
    <Expression4>,
}

Expression4: Expression = {
    <left: Expression4> DASH <right: Expression5> => {
        Expression::Subtract(Box::new(left), Box::new(right))
    },
    <left: Expression4> CROSS <right: Expression5> => {
        Expression::Add(Box::new(left), Box::new(right))
    },
    <Expression5>,
}

Expression5: Expression = {
    <left: Expression5> STAR <right: Expression6> => {
        Expression::Multiply(Box::new(left), Box::new(right))
    },
    <left: Expression5> SLASH <right: Expression6> => {
        Expression::Divide(Box::new(left), Box::new(right))
    },
    <Expression6>,
}

Expression6: Expression = {
    DASH <expression: Expression6> => {
        Expression::Negative(Box::new(expression))
    },
    NOT <expression: Expression6> => {
        Expression::Not(Box::new(expression))
    },
    <Term>,
}

CallExpression: CallExpression = {
    <id: Id> LPAREN <actuals: ActualsList> RPAREN => {
        CallExpression { id, actuals }
    },
    <id: Id> LPAREN  RPAREN => {
        let actuals = Vec::new();
        CallExpression { id, actuals }
    },
}

ActualsList: Vec<Expression> = {
    <expression: Expression> => {
        vec![expression]
    },
    <mut list: ActualsList> COMMA <expression: Expression> => {
        list.push(expression);
        list
    },
}

Term: Expression = {
    <location: Loc> => Expression::Location(location),
    <int: INTLITERAL> => Expression::IntegerLiteral(IntegerLiteral::new(int)),
    <string: STRINGLITERAL> => Expression::StringLiteral(StringLiteral::new(string)),
    TRUE => Expression::True,
    FALSE => Expression::False,
    MAGIC => Expression::Magic,
    LPAREN <Expression> RPAREN,
    <expression: CallExpression> => Expression::CallExpression(expression),
}

Loc: Location = {
    <id: Id> => Location::new_from_id(id),
    <location: Loc> POSTDEC <id: Id> => Location::new_from_location(location, id),
}

Id: Id = {
    <name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
