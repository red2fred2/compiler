use std::{cell::RefCell, rc::Rc};

use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
	r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
	r"\s*" => {},
    _,
}

pub Program: () = {
	Globals,
}

Globals: () = {
	// <program: Globals> <declaration: Declaration> => {
	// 	program.add(declaration);
	// 	program
	// },
	EPSILON,
}

Declaration: () = {
	VariableDeclaration,
	ClassDeclaration,
	FunctionDeclaration,
}

VariableDeclaration: () = {
	Id COLON Type SEMICOLON,
	Id COLON Type ASSIGN Expression SEMICOLON,
}

Type: () = {
	Primitive,
	PERFECT Primitive,
	Id,
	PERFECT Id,
}

pub Primitive: Primitive = {
	INT => Primitive::INT,
	BOOL => Primitive::BOOL,
	VOID => Primitive::VOID,
}

ClassDeclaration: () = {
	Id COLON CLASS LCURLY ClassBody RCURLY SEMICOLON,
}

ClassBody: () = {
	ClassBody VariableDeclaration,
	ClassBody FunctionDeclaration,
	EPSILON,
}

FunctionDeclaration: () = {
	Id COLON LPAREN Formals RPAREN Type LCURLY StatementList RCURLY,
}

Formals: () = {
	FormalsList,
	EPSILON,
}

FormalsList: () = {
	FormalDeclaration,
	FormalDeclaration COMMA FormalsList
}

FormalDeclaration: () = {Id COLON Type}

StatementList: () = {
	StatementList Statement,
	StatementList BlockStatement,
	EPSILON,
}

BlockStatement: () = {
	WHILE LPAREN Expression RPAREN LCURLY StatementList RCURLY,
	IF LPAREN Expression RPAREN LCURLY StatementList RCURLY,
	IF LPAREN Expression RPAREN LCURLY StatementList RCURLY ELSE LCURLY StatementList RCURLY,
}

Statement: () = {
	VariableDeclaration,
	Loc ASSIGN Expression SEMICOLON,
	Loc POSTDEC SEMICOLON,
	Loc POSTINC SEMICOLON,
	GIVE Expression SEMICOLON,
	TAKE Loc SEMICOLON,
	RETURN Expression SEMICOLON,
	RETURN SEMICOLON,
	EXIT SEMICOLON,
	CallExpression SEMICOLON,
}

pub Expression: () = {
	Expression1,
}

Expression1:() = {
	Expression1 OR Expression2,
	Expression2
}

Expression2:() = {
	Expression2 AND Expression3,
	Expression3,
}

Expression3:() = {
	Expression3 EQUALS Expression4,
	Expression3 NOTEQUALS Expression4,
	Expression3 GREATER Expression4,
	Expression3 GREATEREQ Expression4,
	Expression3 LESS Expression4,
	Expression3 LESSEQ Expression4,
	Expression4,
}

pub Expression4: Rc<RefCell<dyn Expression>> = {
	<left: Expression4> DASH <right: Expression5> => rc(Subtract { left, right }),
	<left: Expression4> CROSS <right: Expression5> => rc(Add { left, right }),
	<Expression5>,
}

Expression5: Rc<RefCell<dyn Expression>> = {
	<left: Expression5> STAR <right: Expression6> => rc(Multiply { left, right }),
	<left: Expression5> SLASH <right: Expression6> => rc(Divide { left, right }),
	<Expression6>,
}

Expression6: Rc<RefCell<dyn Expression>> = {
	DASH <expression: Expression6> => {
		rc(Negative { expression })
	},
	NOT <expression: Expression6> => {
		rc(Not { expression })
	},
	<Term>,
}

CallExpression: CallExpression = {
	<id: Id> LPAREN <actuals: ActualsList> RPAREN => {
		CallExpression { id, actuals }
	},
	<id: Id> LPAREN  RPAREN => {
		let actuals = Vec::new();
		CallExpression { id, actuals }
	},
}

ActualsList: Actuals = {
	// Expression,
	// ActualsList COMMA Expression,
	<expression: Expression4> => {
		vec![expression]
	},
	<mut list: ActualsList> COMMA <expression: Expression4> => {
		list.push(expression);
		list
	},
}

Term: Rc<RefCell<dyn Expression>> = {
	// ligma
	<loc: Loc> => rc(loc),
	<int: INTLITERAL> => rc(IntegerLiteral::new(int)),
	<string: STRINGLITERAL> => rc(StringLiteral::new(string)),
	TRUE => rc(Boolean::TRUE),
	FALSE => rc(Boolean::FALSE),
	MAGIC => rc(Magic {}),
	LPAREN <Expression4> RPAREN,
	<expression: CallExpression> => rc(expression),
}

Loc: Loc = {
	<id: Id> => Loc::new_from_id(id),
	<loc: Loc> POSTDEC <id: Id> => Loc::new_from_loc(loc, id),
}

Id: Id = {
	<name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
