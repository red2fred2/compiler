use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
    r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
    r"\s*" => {},
    _,
}

pub Program: () = {
    Globals,
}

Globals: () = {
    // <program: Globals> <declaration: Declaration> => {
    // 	program.add(declaration);
    // 	program
    // },
    EPSILON,
}

Declaration: () = {
    VariableDeclaration,
    ClassDeclaration,
    FunctionDeclaration,
}

VariableDeclaration: () = {
    Id COLON Type SEMICOLON,
    Id COLON Type ASSIGN Expression SEMICOLON,
}

Type: () = {
    Primitive,
    PERFECT Primitive,
    Id,
    PERFECT Id,
}

pub Primitive: Primitive = {
    INT => Primitive::INT,
    BOOL => Primitive::BOOL,
    VOID => Primitive::VOID,
}

ClassDeclaration: () = {
    Id COLON CLASS LCURLY ClassBody RCURLY SEMICOLON,
}

ClassBody: () = {
    ClassBody VariableDeclaration,
    ClassBody FunctionDeclaration,
    EPSILON,
}

FunctionDeclaration: () = {
    Id COLON LPAREN Formals RPAREN Type LCURLY StatementList RCURLY,
}

Formals: () = {
    FormalsList,
    EPSILON,
}

FormalsList: () = {
    FormalDeclaration,
    FormalDeclaration COMMA FormalsList
}

FormalDeclaration: () = {Id COLON Type}

StatementList: () = {
    StatementList Statement,
    StatementList BlockStatement,
    EPSILON,
}

BlockStatement: () = {
    WHILE LPAREN Expression RPAREN LCURLY StatementList RCURLY,
    IF LPAREN Expression RPAREN LCURLY StatementList RCURLY,
    IF LPAREN Expression RPAREN LCURLY StatementList RCURLY ELSE LCURLY StatementList RCURLY,
}

Statement: () = {
    VariableDeclaration,
    Loc ASSIGN Expression SEMICOLON,
    Loc POSTDEC SEMICOLON,
    Loc POSTINC SEMICOLON,
    GIVE Expression SEMICOLON,
    TAKE Loc SEMICOLON,
    RETURN Expression SEMICOLON,
    RETURN SEMICOLON,
    EXIT SEMICOLON,
    CallExpression SEMICOLON,
}

pub Expression: Expression = {
    <Expression1>,
}

Expression1: Expression = {
    <left: Expression1> OR <right: Expression2> => {
        Expression::OR(Box::new(left), Box::new(right))
    },
    <Expression2>
}

Expression2: Expression = {
    <left: Expression2> AND <right: Expression3> => {
        Expression::AND(Box::new(left), Box::new(right))
    },
    <Expression3>,
}

Expression3: Expression = {
    <left: Expression3> EQUALS <right: Expression4> => {
        Expression::EQUALS(Box::new(left), Box::new(right))
    },
    <left: Expression3> NOTEQUALS <right: Expression4> => {
        Expression::NOTEQUALS(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATER <right: Expression4> => {
        Expression::GREATER(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATEREQ <right: Expression4> => {
        Expression::GREATEREQ(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESS <right: Expression4> => {
        Expression::LESS(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESSEQ <right: Expression4> => {
        Expression::LESSEQ(Box::new(left), Box::new(right))
    },
    <Expression4>,
}

Expression4: Expression = {
    <left: Expression4> DASH <right: Expression5> => {
        Expression::SUBTRACT(Box::new(left), Box::new(right))
    },
    <left: Expression4> CROSS <right: Expression5> => {
        Expression::ADD(Box::new(left), Box::new(right))
    },
    <Expression5>,
}

Expression5: Expression = {
    <left: Expression5> STAR <right: Expression6> => {
        Expression::MULTIPLY(Box::new(left), Box::new(right))
    },
    <left: Expression5> SLASH <right: Expression6> => {
        Expression::DIVIDE(Box::new(left), Box::new(right))
    },
    <Expression6>,
}

Expression6: Expression = {
    DASH <expression: Expression6> => {
        Expression::NEGATIVE(Box::new(expression))
    },
    NOT <expression: Expression6> => {
        Expression::NOT(Box::new(expression))
    },
    <Term>,
}

CallExpression: CallExpression = {
    <id: Id> LPAREN <actuals: ActualsList> RPAREN => {
        CallExpression { id, actuals }
    },
    <id: Id> LPAREN  RPAREN => {
        let actuals = Vec::new();
        CallExpression { id, actuals }
    },
}

ActualsList: Vec<Expression> = {
    <expression: Expression> => {
        vec![expression]
    },
    <mut list: ActualsList> COMMA <expression: Expression> => {
        list.push(expression);
        list
    },
}

Term: Expression = {
    <loc: Loc> => Expression::LOC(loc),
    <int: INTLITERAL> => Expression::INTEGERLITERAL(IntegerLiteral::new(int)),
    <string: STRINGLITERAL> => Expression::STRINGLITERAL(StringLiteral::new(string)),
    TRUE => Expression::TRUE,
    FALSE => Expression::FALSE,
    MAGIC => Expression::MAGIC,
    LPAREN <Expression> RPAREN,
    <expression: CallExpression> => Expression::CALLEXPRESSION(expression),
}

Loc: Loc = {
    <id: Id> => Loc::new_from_id(id),
    <loc: Loc> POSTDEC <id: Id> => Loc::new_from_loc(loc, id),
}

Id: Id = {
    <name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
