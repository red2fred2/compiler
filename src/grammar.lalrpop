// use std::{cell::RefCell, rc::Rc};

use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
	r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
	r"\s*" => {},
    _,
}

pub Program: () = {
	Globals,
}

Globals: () = {
	// <program: Globals> <declaration: Declaration> => {
	// 	program.add(declaration);
	// 	program
	// },
	EPSILON,
}

Declaration: () = {
	VariableDeclaration,
	ClassDeclaration,
	FunctionDeclaration,
}

VariableDeclaration: () = {
	Id COLON Type SEMICOLON,
	Id COLON Type ASSIGN Expression SEMICOLON,
}

Type: () = {
	Primitive,
	PERFECT Primitive,
	Id,
	PERFECT Id,
}

Primitive: () = {
	INT,
	BOOL,
	VOID,
}

ClassDeclaration: () = {
	Id COLON CLASS LCURLY ClassBody RCURLY SEMICOLON,
}

ClassBody: () = {
	ClassBody VariableDeclaration,
	ClassBody FunctionDeclaration,
	EPSILON,
}

FunctionDeclaration: () = {
	Id COLON LPAREN Formals RPAREN Type LCURLY StatementList RCURLY,
}

Formals: () = {
	FormalsList,
	EPSILON,
}

FormalsList: () = {
	FormalDeclaration,
	FormalDeclaration COMMA FormalsList
}

FormalDeclaration: () = {Id COLON Type}

StatementList: () = {
	StatementList Statement,
	StatementList BlockStatement,
	EPSILON,
}

BlockStatement: () = {
	WHILE LPAREN Expression RPAREN LCURLY StatementList RCURLY,
	IF LPAREN Expression RPAREN LCURLY StatementList RCURLY,
	IF LPAREN Expression RPAREN LCURLY StatementList RCURLY ELSE LCURLY StatementList RCURLY,
}

Statement: () = {
	VariableDeclaration,
	Loc ASSIGN Expression SEMICOLON,
	Loc POSTDEC SEMICOLON,
	Loc POSTINC SEMICOLON,
	GIVE Expression SEMICOLON,
	TAKE Loc SEMICOLON,
	RETURN Expression SEMICOLON,
	RETURN SEMICOLON,
	EXIT SEMICOLON,
	CallExpression SEMICOLON,
}

Expression: () = {
	Expression1,
}

Expression1:() = {
	Expression1 OR Expression2,
	Expression2
}

Expression2:() = {
	Expression2 AND Expression3,
	Expression3,
}

Expression3:() = {
	Expression3 EQUALS Expression4,
	Expression3 NOTEQUALS Expression4,
	Expression3 GREATER Expression4,
	Expression3 GREATEREQ Expression4,
	Expression3 LESS Expression4,
	Expression3 LESSEQ Expression4,
	Expression4,
}

Expression4:() = {
	Expression4 DASH Expression5,
	Expression4 CROSS Expression5,
	Expression5,
}

Expression5:() = {
	Expression5 STAR Expression6,
	Expression5 SLASH Expression6,
	Expression6,
}

Expression6: () = {
	DASH Expression6,
	NOT Expression6,
	Term,
}

CallExpression: () = {
	Id LPAREN RPAREN,
	Id LPAREN ActualsList RPAREN,
}

ActualsList: () = {
	Expression,
	ActualsList COMMA Expression,
}

Term: () = {
	Loc,
	INTLITERAL,
	STRINGLITERAL,
	TRUE,
	FALSE,
	MAGIC,
	LPAREN Expression RPAREN,
	CallExpression,
}

pub Loc: Loc = {
	<id: Id> => Loc::new_from_id(id),
	<loc: Loc> POSTDEC <id: Id> => Loc::new_from_loc(loc, id),
}

Id: Id = {
	<name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
