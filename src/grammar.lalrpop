use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
    r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
    r"\s*"               => {},
    _,
}

pub Program: Vec<Declaration> = {
    <mut l: Program> <x: Declaration> => {l.push(x); l},
    EPSILON                           => Vec::new(),
}

Declaration = {
    <VariableDeclaration>,
    <ClassDeclaration>,
    <FunctionDeclaration>,
}

VariableDeclaration: Declaration = {
    <name: Id> COLON <t: Type> <assignment: (ASSIGN <Expression>)?> SEMICOLON =>
        Declaration::new_variable(name, t, assignment),
}

Type: Type = {
    <t: Primitive>         => Type::Primitive(t),
    PERFECT <t: Primitive> => Type::PerfectPrimitive(t),
    <t: Id>                => Type::Class(t),
    PERFECT <t: Id>        => Type::PerfectClass(t),
}

Primitive: Primitive = {
    INT  => Primitive::Int,
    BOOL => Primitive::Bool,
    VOID => Primitive::Void,
}

ClassDeclaration: Declaration = {
    <id: Id> COLON CLASS LCURLY <body: ClassBody> RCURLY SEMICOLON =>
        Declaration::new_class(id, body),
}

ClassBody: Vec<Declaration> = {
    <mut l: ClassBody> <x: VariableDeclaration> => {l.push(x); l},
    <mut l: ClassBody> <x: FunctionDeclaration> => {l.push(x); l},
    EPSILON                                     => Vec::new(),
}

FunctionDeclaration: Declaration = {
    <id: Id> COLON LPAREN <fn_input: Formals> RPAREN <fn_output: Type> LCURLY <body: StatementList> RCURLY =>
        Declaration::new_function(id, fn_input, fn_output, body),
}

Formals = {
    <FormalsList>,
    EPSILON => Vec::new(),
}

FormalsList: Vec<Formal> = {
    <x: FormalDeclaration>                            => vec![x],
    <mut l: FormalsList> COMMA <x: FormalDeclaration> => {l.push(x); l},
}

FormalDeclaration: Formal = {
    <id: Id> COLON <t: Type> => Formal { id, t },
}

StatementList: Vec<Statement> = {
    <mut l: StatementList> <x: Statement>      => {l.push(x); l},
    <mut l: StatementList> <x: BlockStatement> => {l.push(x); l},
    EPSILON                                    => Vec::new(),
}

BlockStatement: Statement = {
    WHILE LPAREN <condition: Expression> RPAREN LCURLY <body: StatementList> RCURLY =>
        Statement::While { condition, body },
    IF LPAREN <condition: Expression> RPAREN LCURLY <body: StatementList> RCURLY <else_body: (ELSE LCURLY <StatementList> RCURLY)?> => {
        let else_body = match else_body {
            Some(x) => x,
            None => Vec::new(),
        };

        Statement::If {condition, body, else_body }
    },
}

Statement: Statement = {
    <x: VariableDeclaration>                  => Statement::VariableDeclaration(x),
    <x: Loc> ASSIGN <y: Expression> SEMICOLON => Statement::Assignment(x, y),
    <x: Loc> POSTDEC SEMICOLON                => Statement::Decrement(x),
    <x: Loc> POSTINC SEMICOLON                => Statement::Increment(x),
    GIVE <x: Expression> SEMICOLON            => Statement::Give(x),
    TAKE <x: Loc> SEMICOLON                   => Statement::Take(x),
    RETURN <x: (<Expression>)?> SEMICOLON     => Statement::Return(x),
    EXIT SEMICOLON                            => Statement::Exit,
    <x: CallExpression> SEMICOLON             => Statement::CallExpression(x),
}

Expression = {
    <l: Expression> OR <r: Expression2> => Expression::Or(b(l), b(r)),
    <Expression2>,
}

Expression2 = {
    <l: Expression2> AND <r: Expression3> => Expression::And(b(l), b(r)),
    <Expression3>,
}

Expression3 = {
    <l: Expression3> EQUALS <r: Expression4>    => Expression::Equals(b(l), b(r)),
    <l: Expression3> NOTEQUALS <r: Expression4> => Expression::NotEquals(b(l), b(r)),
    <l: Expression3> GREATER <r: Expression4>   => Expression::Greater(b(l), b(r)),
    <l: Expression3> GREATEREQ <r: Expression4> => Expression::GreaterEq(b(l), b(r)),
    <l: Expression3> LESS <r: Expression4>      => Expression::Less(b(l), b(r)),
    <l: Expression3> LESSEQ <r: Expression4>    => Expression::LessEq(b(l), b(r)),
    <Expression4>,
}

Expression4 = {
    <l: Expression4> DASH <r: Expression5>  => Expression::Subtract(b(l), b(r)),
    <l: Expression4> CROSS <r: Expression5> => Expression::Add(b(l), b(r)),
    <Expression5>,
}

Expression5 = {
    <l: Expression5> STAR <r: Expression6>  => Expression::Multiply(b(l), b(r)),
    <l: Expression5> SLASH <r: Expression6> => Expression::Divide(b(l), b(r)),
    <Expression6>,
}

Expression6 = {
    DASH <x: Expression6> => Expression::Negative(b(x)),
    NOT <x: Expression6>  => Expression::Not(b(x)),
    <Term>,
}

CallExpression: CallExpression = {
    <id: Id> LPAREN <actuals: ActualsList> RPAREN => {
        CallExpression { id, actuals }
    },
    <id: Id> LPAREN  RPAREN => {
        let actuals = Vec::new();
        CallExpression { id, actuals }
    },
}

ActualsList: Vec<Expression> = {
    <x: Expression>                            => vec![x],
    <mut l: ActualsList> COMMA <x: Expression> => {l.push(x); l},
}

Term: Expression = {
    <x: Loc>            => Expression::Location(x),
    <x: INTLITERAL>     => Expression::new_int(x),
    <x: STRINGLITERAL>  => Expression::new_string(x),
    <x: CallExpression> => Expression::CallExpression(x),
    TRUE                => Expression::True,
    FALSE               => Expression::False,
    MAGIC               => Expression::Magic,
    LPAREN <Expression> RPAREN,
}

Loc: Location = {
    <id: Id>                         => Location::new_from_id(id),
    <location: Loc> POSTDEC <id: Id> => Location::new_from_location(location, id),
}

Id: Id = {
    <name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
