use crate::ast::*;

grammar;

match {} else {
    // Ignore comments
    r"//[^\n\r]*[\n\r]*" => {},
    // Ignore whitespace
    r"\s*" => {},
    _,
}

pub Program: () = {
    Globals,
}

Globals: () = {
    // <program: Globals> <declaration: Declaration> => {
    // 	program.add(declaration);
    // 	program
    // },
    EPSILON,
}

Declaration: () = {
    VariableDeclaration,
    ClassDeclaration,
    FunctionDeclaration,
}

VariableDeclaration: VariableDeclaration = {
    <name: Id> COLON <t: Type> <assignment: (ASSIGN <Expression>)?> SEMICOLON => {
        VariableDeclaration { name, t, assignment }
     },
}

Type: Type = {
    <t: Primitive> => Type::Primitive(t),
    PERFECT <t: Primitive> => Type::PerfectPrimitive(t),
    <t: Id> => Type::Class(t),
    PERFECT <t: Id> => Type::PerfectClass(t),
}

Primitive: Primitive = {
    INT => Primitive::Int,
    BOOL => Primitive::Bool,
    VOID => Primitive::Void,
}

ClassDeclaration: () = {
    Id COLON CLASS LCURLY ClassBody RCURLY SEMICOLON,
}

ClassBody: () = {
    ClassBody VariableDeclaration,
    ClassBody FunctionDeclaration,
    EPSILON,
}

FunctionDeclaration: () = {
    Id COLON LPAREN Formals RPAREN Type LCURLY StatementList RCURLY,
}

Formals: () = {
    FormalsList,
    EPSILON,
}

FormalsList: () = {
    FormalDeclaration,
    FormalDeclaration COMMA FormalsList
}

FormalDeclaration: () = {Id COLON Type}

StatementList: Vec<Statement> = {
    <mut list: StatementList> <item: Statement> => {
        list.push(item);
        list
    },
    // StatementList BlockStatement,
    EPSILON => Vec::new(),
}

pub BlockStatement: BlockStatement = {
    WHILE LPAREN <condition: Expression> RPAREN LCURLY <then: StatementList> RCURLY => {
        BlockStatement::While(condition, then)
    },
    IF LPAREN <condition: Expression> RPAREN LCURLY <then: StatementList> RCURLY <alt: (ELSE LCURLY <StatementList> RCURLY)?> => {
        let alt = match alt {
            Some(a) => a,
            None => Vec::new(),
        };

        BlockStatement::If(condition, then, alt)
    },
}

Statement: Statement = {
    <declaration: VariableDeclaration> => {
        Statement::VariableDeclaration(declaration)
    },
    <location: Loc> ASSIGN <expression: Expression> SEMICOLON => {
        Statement::Assignment(location, expression)
    },
    <location: Loc> POSTDEC SEMICOLON => {
        Statement::Decrement(location)
    },
    <location: Loc> POSTINC SEMICOLON => {
        Statement::Increment(location)
    },
    GIVE <expression: Expression> SEMICOLON => {
        Statement::Give(expression)
    },
    TAKE <location: Loc> SEMICOLON => {
        Statement::Take(location)
    },
    RETURN <expression: (<Expression>)?> SEMICOLON => {
        Statement::Return(expression)
    },
    EXIT SEMICOLON => {
        Statement::Exit
    },
    <call: CallExpression> SEMICOLON => {
        Statement::CallExpression(call)
    },
}

Expression: Expression = {
    <Expression1>,
}

Expression1: Expression = {
    <left: Expression1> OR <right: Expression2> => {
        Expression::Or(Box::new(left), Box::new(right))
    },
    <Expression2>
}

Expression2: Expression = {
    <left: Expression2> AND <right: Expression3> => {
        Expression::And(Box::new(left), Box::new(right))
    },
    <Expression3>,
}

Expression3: Expression = {
    <left: Expression3> EQUALS <right: Expression4> => {
        Expression::Equals(Box::new(left), Box::new(right))
    },
    <left: Expression3> NOTEQUALS <right: Expression4> => {
        Expression::NotEquals(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATER <right: Expression4> => {
        Expression::Greater(Box::new(left), Box::new(right))
    },
    <left: Expression3> GREATEREQ <right: Expression4> => {
        Expression::GreaterEq(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESS <right: Expression4> => {
        Expression::Less(Box::new(left), Box::new(right))
    },
    <left: Expression3> LESSEQ <right: Expression4> => {
        Expression::LessEq(Box::new(left), Box::new(right))
    },
    <Expression4>,
}

Expression4: Expression = {
    <left: Expression4> DASH <right: Expression5> => {
        Expression::Subtract(Box::new(left), Box::new(right))
    },
    <left: Expression4> CROSS <right: Expression5> => {
        Expression::Add(Box::new(left), Box::new(right))
    },
    <Expression5>,
}

Expression5: Expression = {
    <left: Expression5> STAR <right: Expression6> => {
        Expression::Multiply(Box::new(left), Box::new(right))
    },
    <left: Expression5> SLASH <right: Expression6> => {
        Expression::Divide(Box::new(left), Box::new(right))
    },
    <Expression6>,
}

Expression6: Expression = {
    DASH <expression: Expression6> => {
        Expression::Negative(Box::new(expression))
    },
    NOT <expression: Expression6> => {
        Expression::Not(Box::new(expression))
    },
    <Term>,
}

CallExpression: CallExpression = {
    <id: Id> LPAREN <actuals: ActualsList> RPAREN => {
        CallExpression { id, actuals }
    },
    <id: Id> LPAREN  RPAREN => {
        let actuals = Vec::new();
        CallExpression { id, actuals }
    },
}

ActualsList: Vec<Expression> = {
    <expression: Expression> => {
        vec![expression]
    },
    <mut list: ActualsList> COMMA <expression: Expression> => {
        list.push(expression);
        list
    },
}

Term: Expression = {
    <location: Loc> => Expression::Location(location),
    <int: INTLITERAL> => Expression::IntegerLiteral(IntegerLiteral::new(int)),
    <string: STRINGLITERAL> => Expression::StringLiteral(StringLiteral::new(string)),
    TRUE => Expression::True,
    FALSE => Expression::False,
    MAGIC => Expression::Magic,
    LPAREN <Expression> RPAREN,
    <expression: CallExpression> => Expression::CallExpression(expression),
}

Loc: Location = {
    <id: Id> => Location::new_from_id(id),
    <location: Loc> POSTDEC <id: Id> => Location::new_from_location(location, id),
}

Id: Id = {
    <name: ID> => Id {name: name.to_string()},
}

// Terminal symbols
AND = {"and"}
ASSIGN = {"="}
BOOL = {"bool"}
CLASS = {"class"}
COLON = {":"}
COMMA = {","}
CROSS = {"+"}
DASH = {"-"}
ELSE = {"else"}
EPSILON = {()}
EQUALS = {"=="}
EXIT = {"today I don't feel like doing any work"}
FALSE = {"false"}
GIVE = {"give"}
GREATER = {">"}
GREATEREQ = {">="}
ID = {r"[a-zA-Z_][a-zA-Z_\d]*"}
IF = {"if"}
INT = {"int"}
INTLITERAL = {r"\d+"}
LCURLY = {"{"}
LESS = {"<"}
LESSEQ = {"<="}
LPAREN = {"("}
MAGIC = {"24Kmagic"}
NOT = {"!"}
NOTEQUALS = {"!="}
OR = {"or"}
PERFECT = {"perfect"}
POSTDEC = {"--"}
POSTINC = {"++"}
RCURLY = {"}"}
RETURN = {"return"}
RPAREN = {")"}
SEMICOLON = {";"}
SLASH = {"/"}
STAR = {"*"}
STRINGLITERAL = {r#""(?:[^\\\"]|\\.)*""#}
TAKE = {"take"}
TRUE = {"true"}
VOID = {"void"}
WHILE = {"while"}
